什么是递归？
  递归可以拆分成两部分，递推和回溯
  拆解后，每一次都是基于上一次进行下一次的执行，这叫递推
  回溯：则是在遇到终止条件，则从最后往回返一级一级的把值返回来，这叫回溯
  
  总结成一句话：每一次当下的运算过程，都可以参考上一次的运算过程，可以把所有的运算过程都抽象成一次运算。这个方法就叫做递归。

运用递归的经典案例：
  1.汉诺塔
  2.斐波那契数列
  3.二分查找

什么是汉诺塔?
  从左到右三根柱子分别为A,B,C。
  A柱子上有n个圆盘，规定一次只能移动一片，且大盘不能放在小盘上方。
  问：怎么移动才能把A柱上的所有圆盘，都移动到C柱上，写出移动过程和总移动次数。
  
  思路：
  分为两种情况，第一种情况是只有一个圆片，要把圆片从A移动到C，直接从A移动到C就可以了。																				
  第二种情况，有两个以上的圆片，假设有两个圆片，首先将第一片移动到B，然后将身下的那个第二片及最大的那一片，移动到C，再把B上的第一片移动到C，完成。
  接下来无论是三片四片还是几片，都会遵循先将除最后一片的所有圆片都移动到B上，然后将最后大的那一片移动到C，再将B上所有的圆片都移动到C上，完成。
  抽象成三步骤，假设有n个圆片：
  第一步，将n-1片圆片都移动到B；
  第二步，将第n片移动到A；
  第三步，将n-1片都移动到C。
  所以，重点不在于多少片，而在于三根柱子，就像盲僧q同时摸眼，不在于q而在于w。
  
  下面根据这三个步骤来写python的代码:
    有四个变量：n个圆片，柱子A，柱子B,柱子C
    def move(n,A,B,C):
      #第一种情况：只有一个圆片
      if n == 1:
        print(A,'----->',C)
      #第二种情况：多于一个圆片
      else：
        #先将A柱上n-1个圆片移动到B柱，C柱空闲
        move(n-1,A,C,B)
        #为什么这么写，我的理解是：在最初定义函数时，def move(n,A,B,C):这句话，就已经把B柱子所在的位置当作了一个空闲位置，所以在接下来那根柱子空闲下来，就要写在最初B柱空闲的那个位置上。
        #插入一个概念，空闲，在计算机中叫做缓冲区
        #缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。

        #然后将A柱上第n片移动到C柱
        print(A,'---->',C)

        #最后将B柱上n-1片移动到C柱,A柱空闲
        move(n-1,B,A,C)
    
    n = int(input("请输入n的值："))
    move(n,"A","B","C")

  
  注意点：
    第一眼看这个代码，有一种程序只有一个print怎么会输出每一步呢，这样的疑问。后来一看，print(A,'---->',C)中的A和C是变量。
    递归，其实是调用上一步的函数，而函数中的参数，每一次都在发生着变化。A和C的值会不断发生变化，而模式不变。所以才会被称为递归。
  
  TODO
  Debug过程：
  时间复杂度和空间复杂度的计算：
  斐波那契数列：
  二分查找：
  深度优先搜索（也叫回溯法），其特征是一直向下搜索，无法继续时返回。空间复杂度低。
  广度优先搜索，特征是先搜索某一点最近的节点，然后往下扩散，一层一层的向外扩散。时间复杂度低。
      
      
